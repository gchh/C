##第七周编程题  
###1 单词长度（4分）
题目内容：  
你的程序要读入一行文本，其中以空格分隔为若干个单词，以‘.’结束。你要输出这行文本中每个单词的长度。这里的单词与语言无关，可以包括各种符号，比如“it's”算一个单词，长度为4。注意，行中可能出现连续的空格。  

输入格式:  
输入在一行中给出一行文本，以‘.’结束，结尾的句号不能计算在最后一个单词的长度内。  

输出格式：  
在一行中输出这行文本对应的单词的长度，每个长度之间以空格隔开，行末没有最后的空格。  

输入样例：  
It's great to see you here.  

输出样例：  
4 5 2 3 3 4  

时间限制：500ms内存限制：32000kb  

解题思路：  
这一题的测试点挺多。像下面的都要排除：  


- ___________i 起始有空格  
- i　　　 love. 有连续的空格  
- 　　 　　. 单独一个点的情况。  
这个程序最大的问题还可能在对末尾不能包含有空格的处理上。  
本解法的思路是遇到下一个单词时，才输出上一个单词的位数，判断条件是统计的单词位数大于 0 且其后有空格，这时候输出的位数有空格。这样最后一个单词（它没有下一个单词）就可以单独输出不带空格的位数。  
文末的第二种解法提供了另外一种思路。增加了一个单词统计量，第一个单词输出时前方不加空格，此后前方都加空格。  

解题代码：

		#include<stdio.h> // 算法一
		
		int main ()
		{
		    int count = 0, count_0 = 0;
		    char n;
		    while((n = getchar()) != '.') {
		        if (n != ' ') {
		            if (count > 0 && count_0 > 0) { //当且仅当字母位数大于 0 时且后方有空格时才输出带有空格的位数 
		                printf("%d ", count);
		                count = 0;
		            }
		            count ++;
		            count_0 = 0;  
		            continue;   
		        } 
		        if (n == ' ') {
		            count_0 ++;
		        }       
		    }
		    if (count > 0) {  // 输出最后一个单词的个数 
		        printf("%d\n", count);
		    } else {
		        printf("\n"); // 处理只有一个 . 的情况  
		    }
		    
		    return 0; 
		}

##
	#include<stdio.h> // 算法二
	  
	int main(void)
	{
	    char c;
	    int cnt = 0, count = 0; //统计单词的个数 
	     
	    do {
	        scanf("%c", &c);
	        if ( cnt==0 && c==' ' ) {
	            continue;
	        } // 解决单词与单词之间多个空格的问题 
	        if ( cnt==0 && c=='.') {
	            break;
	        } // 解决单词与最后的'.'之间有空格的问题 
	        if( c==' ' ) {
	             if ( count==0 ) {
	                printf("%d", cnt);  //第一个单词前不加空格 
	             } else {
	                printf(" %d", cnt);
	             }
	             cnt = 0;
	             count++;
	             continue;
	        } 
	        if( c=='.' ) {
	             if ( count==0 ) {
	                printf("%d", cnt); 
	             } else {
	                printf(" %d", cnt);
	             } 
	             break;
	        }
	            cnt++;
	    } while ( c!='.' );
	 
	    return 0;
	}  

###2 GPS数据处理（6分）
题目内容：  
NMEA-0183协议是为了在不同的GPS（全球定位系统）导航设备中建立统一的BTCM（海事无线电技术委员会）标准，由美国国家海洋电子协会（NMEA-The National Marine Electronics Associa-tion）制定的一套通讯协议。GPS接收机根据NMEA-0183协议的标准规范，将位置、速度等信息通过串口传送到PC机、PDA等设备。  

NMEA-0183协议是GPS接收机应当遵守的标准协议，也是目前GPS接收机上使用最广泛的协议，大多数常见的GPS接收机、GPS数据处理软件、导航软件都遵守或者至少兼容这个协议。  

NMEA-0183协议定义的语句非常多，但是常用的或者说兼容性最广的语句只有$GPGGA、$GPGSA、$GPGSV、$GPRMC、$GPVTG、$GPGLL等。  

其中$GPRMC语句的格式如下：  

	$GPRMC,024813.640,A,3158.4608,N,11848.3737,E,10.05,324.27,150706,,,A*50

这里整条语句是一个文本行，行中以逗号“,”隔开各个字段，每个字段的大小（长度）不一，这里的示例只是一种可能，并不能认为字段的大小就如上述例句一样。  

    字段0：$GPRMC，语句ID，表明该语句为Recommended Minimum Specific GPS/TRANSIT Data（RMC）推荐最小定位信息  
    字段1：UTC时间，hhmmss.sss格式  
    字段2：状态，A=定位，V=未定位  
    字段3：纬度ddmm.mmmm，度分格式（前导位数不足则补0）  
    字段4：纬度N（北纬）或S（南纬）  
    字段5：经度dddmm.mmmm，度分格式（前导位数不足则补0）  
    字段6：经度E（东经）或W（西经）  
    字段7：速度，节，Knots  
    字段8：方位角，度  
    字段9：UTC日期，DDMMYY格式  
    字段10：磁偏角，（000 - 180）度（前导位数不足则补0）  
    字段11：磁偏角方向，E=东W=西  
    字段16：校验值  
    这里，“\*”为校验和识别符，其后面的两位数为校验和，代表了“$”和“\*”之间所有字符（不包括这两个字符）的异或值的十六进制值。上面这条例句的校验和是十六进制的50，也就是十进制的80。  

提示：^运算符的作用是异或。将$和\*之间所有的字符做^运算(第一个字符和第二个字符异或，结果再和第三个字符异或，依此类推)之后的值对65536取余后的结果，应该和\*后面的两个十六进制数字的值相等，否则的话说明这条语句在传输中发生了错误。注意这个十六进制值中是会出现A-F的大写字母的。另外，如果你需要的话，可以用sscanf(s,"%d", &i)从字符串s中得到其所表达的整数数字给i。  

现在，你的程序要读入一系列GPS输出，其中包含$GPRMC，也包含其他语句。在数据的最后，有一行单独的  
END  
表示数据的结束。 

你的程序要从中找出$GPRMC语句，计算校验和，找出其中校验正确，并且字段2表示已定位的语句，从中计算出时间，换算成北京时间。一次数据中会包含多条$GPRMC语句，以最后一条语句得到的北京时间作为结果输出。  

你的程序一定会读到一条有效的$GPRMC语句。  

输入格式:  
多条GPS语句，每条均以回车换行结束。最后一行是END三个大写字母。  

输出格式：  
6位数时间，表达为：  
hh:mm:ss  
其中，hh是两位数的小时，不足两位时前面补0；mm是两位数的分钟，不足两位时前面补0；ss是两位数的秒，不足两位时前面补0。  

输入样例：  
$GPRMC,024813.640,A,3158.4608,N,11848.3737,E,10.05,324.27,150706,,,A*50  
END  

输出样例：  
10:48:13  

时间限制：500ms内存限制：32000kb  

	#include <stdio.h>
	#include <string.h>
	//#include <math.h>
	//#include<stdlib.h>
	#define GPS_ARRAY_SIZE 1000
	void gps(char str[], int times[]);
	int main(int argc, const char * argv[]) 
	{
		// insert code here...
		// TODO Auto-generated method stub
		char word[GPS_ARRAY_SIZE];
		int times[3]={0};
		char end[]="END";
		do
		{
			scanf("%s",word);
			gps(word,times);
		}while(strcmp(word,end)!=0);
		printf("%02d:%02d:%02d\n",times[0],times[1],times[2]);
		return 0;
	}
	/*GPS数据处理
	str[]是一行GPS数据，times[]长度为3，存储验证通过的时间的时分秒数
	*/
	void gps(char str[], int times[])
	{
		int i;
		if(str[0]=='$'&&str[1]=='G'&&str[2]=='P'&&str[3]=='R'&&str[4]=='M'&&str[5]=='C'&&str[6]!='\0')
		{
			//处理$和*之间所有字符异或
			int sum = 0; //异或值
			for(i=1; str[i]!='*'; i++)
			{
				sum = sum ^ str[i];
			}
			//处理*后的字符
			char c1=str[i+1], c2=str[i+2];
			//int1,int2存储校验字符的整型值，mask存储int1,int2转换为10进制
			int int1, int2, mask;
			if(c1 >='A' && c1<='F')
			{
				int1 = 10+(c1-'A');
			}
			else
			{
				int1 = c1 - '0';
			}
			if(c2 >='A' && c2<='F')
			{
				int2 = 10+(c2-'A');
			}
			else
			{
				int2 = c2 - '0';
			}
			mask = int1*16 + int2; //16进制转10进制
			//找出状态值
			for(i=7; str[i]!='*'; i++)
			{ 
				//从第一个逗号后面开始遍历
				if(str[i]==',')break;
			}
			if(str[i+1]=='A'&&mask==sum)
			{
				int hour = 10*(str[7]-'0') + (str[8]-'0'); //小时
				hour = (hour + 8) % 24;
				times[0] = hour;
				times[1] = 10 * (str[9] - '0') + (str[10] - '0'); //分钟
				times[2] = 10 * (str[11] - '0') + (str[12] - '0'); //秒
			}
		}
	}  
